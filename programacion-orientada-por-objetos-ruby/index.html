<!DOCTYPE html>
<html lang="es">
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title> Programación Orientada por Objetos en Ruby </title>
  <meta name="description" content="La Programación Orientada por Objetos, también conocida por las siglas OOP (Object Oriented Programming), surgió a principios de los años 80’s como respuesta...">

  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta property="og:title" content="Programación Orientada por Objetos en Ruby">
<meta property="og:type" content="article">
<meta property="og:url" content="http://blog.makeitreal.camp/programacion-orientada-por-objetos-ruby/">


  <meta property="og:image" content="http://blog.makeitreal.camp/assets/images/bg-images/object-oriented-programming.jpg">



<meta property="og:site_name" content="El Blog de Make it Real">
<meta property="og:locale" content="es_CO">


  <meta property="article:published_time" content="2015-02-23T12:00:00-05:00">
  <meta property="article:author" content="Germán Escobar">



  <link rel="canonical" href="http://blog.makeitreal.camp/programacion-orientada-por-objetos-ruby/">
  <link rel="alternate" type="application/rss+xml" title="El Blog de Make it Real" href="/feed.xml">

  <link rel='stylesheet' href='//fonts.googleapis.com/css?family=Open+Sans+Condensed:700|Open+Sans:400,300,600,700' type='text/css'>
  <link rel="stylesheet" href="/assets/stylesheets/main.css">

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="/assets/javascripts/main.js" charset="utf-8"></script>
  <script src="/assets/javascripts/prism.min.js" charset="utf-8"></script>

  
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  
  ga('create', 'UA-18132057-9', 'auto');
  ga('send', 'pageview');
</script>

  
</head>

  <body>
    <nav class="main">
  <div class="container">
    <div class="main-content">
      <a href="https://makeitreal.camp/?utm_source=blog&utm_medium=web&utm_campaign=inbound&utm_content=logo"><img src="/assets/images/logo-makeitreal-white.png" alt="Make it Real Logo"></a>
      <a href="https://makeitreal.camp/?utm_source=blog&utm_medium=web&utm_campaign=inbound&utm_content=programs#programs" class="btn-cta">Conoce nuestros programas</a>
      <div class="secret" style="display: none;">HcUy6Re2LLBRtj</div>
    </div>
  </div>
</nav>

    <div class="content"><div class="post-page">
  <div class="container">
    <div class="row justify-content-md-center">
      <div class="col-lg-10 col-xl-9">
        <a href="/">&larr; Volver a la lista de posts</a>

        <div class="post">
          <div class="post-image" style="background-image: url(/assets/images/bg-images/object-oriented-programming.jpg)"></div>
          <div class="row justify-content-md-center">
            <div class="col-md-10">
              <div class="post-content">
                <div class="post-details">
                  <div class="post-author">
                    <img class="img-responsive" src="//www.gravatar.com/avatar/12270acfe9b6842e1a5b6e594382f149.jpg?s=80"/>
                    <span>Germán Escobar</span>
                  </div>
                  <time class="post-date">Feb 23, 2015</time>
                </div>
                <h1>Programación Orientada por Objetos en Ruby</h1>
                <div class="post-body"><p>La Programación Orientada por Objetos, también conocida por las siglas <strong>OOP (Object Oriented Programming)</strong>, surgió a principios de los años 80’s como respuesta a la dificultad que estaban experimentando los programadores manteniendo aplicaciones de tamaño y complejidad considerables.<!-- more --> Cualquier cambio desencadenaba una reacción en cadena de errores ocasionados por las dependencias que existían en la aplicación. Hasta ese entonces se usaba un paradigma llamado <a href="http://es.wikipedia.org/wiki/Programaci%C3%B3n_por_procedimientos" target="_blank">Programación Procedimental</a>.</p>

<blockquote>Las aplicaciones evolucionan. Los requerimientos y la tecnología cambian. Pero una aplicación bien diseñada es fácil de mantener y actualizar en el tiempo.</blockquote>

<p>La <a href="http://es.wikipedia.org/wiki/Programaci%C3%B3n_por_procedimientos" target="_blank">Programación Procedimental</a> hace uso de ciclos, condicionales, y procedimientos para crear aplicaciones. <strong>La Programación Orientada por Objetos introduce varios conceptos que permiten mejorar la organización y la reutilización del código, haciendo más fácil el mantenimiento de la aplicación a mediano y largo plazo</strong>. Entre esos conceptos se encuentran: objetos, clases, encapsulamiento, polimorfismo, herencia, y mixins (o módulos), entre otros.</p>

<p>Es importante entender que la Programación Orientada por Objetos no reemplaza la Programación Procedimental, la extiende para hacer el código más mantenible y reutilizable. En la OOP se siguen usando ciclos, condicionales, y procedimientos (métodos). Tus actividades del día a día, por ejemplo, ocurren de forma secuencial (tomas decisiones y realizas actividades, algunas de ellas repetitivas). Eso es procedimental. Pero, al mismo tiempo, el mundo está compuesto de objetos que hacen parte activa o pasiva de esas actividades (humanos, carros, edificios, etc.). Podemos decir, entonces, que <strong>nuestra realidad es procedimental y orientada a objetos al mismo tiempo.</strong></p>

<p><br />
<img src="/assets/images/proc-vs-oo.png" alt="Screenshots" class="photo" /></p>

<p class="photo-description">La Programación Procedimental se encarga de la secuencia de eventos, la Programación Orientada por Objetos de la organización y visibilidad del código.</p>

<p>Pero explicar y entender la Programación Orientada por Objetos no es fácil. Por un lado, los beneficios no son evidentes en aplicaciones simples, hechas por una única persona, que no cambian en el tiempo. Por otro lado, no hay una forma “correcta” de usar OOP, solo “mejores prácticas”, sugerencias sobre cómo diseñar las aplicaciones. <strong>Es el tiempo el que decide si una aplicación está bien diseñada o no. Y es la experiencia creando y manteniendo varias aplicaciones la que desarrolla esa intuición en el programador</strong>.</p>

<p>Por ejemplo, en Ruby on Rails es posible hacer una aplicación Web relativamente compleja sin saber -prácticamente nada- de Programación Orientada por Objetos. Eso es una ventaja si el objetivo es hacer un prototipo de una aplicación Web lo más rápido posible, pero una desventaja a la hora de trabajar en aplicaciones más complejas, escritas por múltiples personas, y que deben ser mantenidas por varios años.</p>

<p><strong>Conocer y aplicar correctamente la Programación Orientada por Objetos es uno de los tres aspectos fundamentales que separan a los desarrolladores Junior de los Senior. Los otros dos siendo el código limpio y las pruebas automatizadas.</strong></p>

<h2 id="clases-y-objetos">Clases y Objetos</h2>

<p>Las clases y los objetos son los conceptos más importantes de la Programación Orientada por Objetos, y están fuertemente relacionados. <strong>Los objetos se crean a partir de clases, y las clases definen los atributos y el comportamiento que tendrán los objetos</strong>. A los objetos también se les llama <em>instancias de clase</em>.</p>

<p>Veamos cómo definir una clase y crear objetos en Ruby:</p>

<pre><code class="language-ruby">class Humano
end

juan = Humano.new
pedro = Humano.new
ana = Humano.new</code></pre>

<p>En este ejemplo, hemos definido una clase llamada <code class="highlighter-rouge">Humano</code> y creamos tres objetos usando <code class="highlighter-rouge">Humano.new</code>, que almacenamos en las variables <code class="highlighter-rouge">juan</code>, <code class="highlighter-rouge">pedro</code>, y <code class="highlighter-rouge">ana</code>. La clase aún no tiene atributos ni comportamiento.</p>

<p>Ahora modifiquemos la clase <strong>Humano</strong> para definir algunos atributos (nombre, edad y género), y un comportamiento (saludar):</p>

<pre><code class="language-ruby">class Humano
  attr_accessor :name, :age, :genre

  def greet
    puts "Hola, me llamo #{@name}"
  end
end</code></pre>

<p><code class="highlighter-rouge">attr_accessor</code> determina que los atributos se van a poder leer y escribir desde cualquier parte de la aplicación. Otras opciones son <code class="highlighter-rouge">attr_reader</code> (solo lectura) y <code class="highlighter-rouge">attr_writer</code> (solo escritura). A esto se le llama <strong>la visibilidad</strong> del atributo y corresponde al concepto de <strong>encapsulamiento</strong> que veremos más adelante.</p>

<p>La clase define un comportamiento, <code class="highlighter-rouge">greet</code> (saludar), que no es más que una función dentro de la clase. <strong>A las funciones que están definidias en clases se les llama métodos</strong>. Los métodos pueden usar los atributos del objeto usando el prefijo <code class="highlighter-rouge">@</code> como lo hace el método <code class="highlighter-rouge">greet</code>.</p>

<p>Para leer y escribir los atributos de un objeto, o llamar sus métodos, se usa la notación <code class="highlighter-rouge">objeto.atributo</code> u <code class="highlighter-rouge">objeto.método</code> como se muestra en el siguiente ejemplo:</p>

<pre><code class="language-ruby">juan = Humano.new
juan.name = "Juan Perez"
juan.age = 12
juan.genre = "M"

puts juan.name # imprime Juan Perez
puts juan.age # imprime 12
puts juan.genre # imprime M

puts juan.greet # imprime Hola, me llamo Juan Perez</code></pre>

<h2 id="inicializando-un-objeto">Inicializando un objeto</h2>

<p>Al ejecutar la línea <code class="highlighter-rouge">Humano.new</code>, Ruby busca un método llamado <code class="highlighter-rouge">initialize</code> que, si existe, se invoca automáticamente. A este método se le llama <strong>el constructor</strong>.</p>

<pre><code class="language-ruby">class Humano
  attr_accessor :name, :age, :genre

  def initialize
    puts "Inicializando humano ..."
  end
 end</code></pre>

<p>En este ejemplo, cada vez que invoquemos <code class="highlighter-rouge">Humano.new</code>, se imprimirá la cadena “Inicializando Humano”.</p>

<p>El método <code class="highlighter-rouge">initialize</code> puede recibir argumentos, que nos pueden servir para inicializar los atributos del objeto.</p>

<pre><code class="language-ruby">class Humano
  attr_accessor :name, :age, :genre

  def initialize(name, age, genre)
    @name = name
    @age = age
    @genre = genre
  end
end</code></pre>

<p>El constructor ahora recibe tres argumentos que se utilizan para inicializar los atributos del objeto:</p>

<pre><code class="language-ruby">juan = Humano.new("Juan Perez", 12, "M")</code></pre>

<h2 id="en-ruby-casi-todo-es-un-objeto">En Ruby (casi) todo es un objeto</h2>

<p>Por ejemplo, la clase <code class="highlighter-rouge">String</code> de la que se crean las cadenas (strings), tienen comportamiento (métodos) que podemos llamar con la notación <code class="highlighter-rouge">objeto.método</code>:</p>

<pre><code class="language-ruby">puts "hola".capitalize # HOLA
puts "hola".reverse # aloh</code></pre>

<p>En este caso, la clase <code class="highlighter-rouge">String</code> define los métodos <code class="highlighter-rouge">capitalize</code> y <code class="highlighter-rouge">reverse</code>. Puedes encontrar todos los métodos que se pueden llamar sobre las cadenas (strings) en la <a href="http://ruby-doc.org/core-2.2.0/String.html" target="_blank">documentación de Ruby</a>.</p>

<p>Los enteros también tienen comportamiento:</p>

<pre><code class="language-ruby">puts 2.even? # true
puts 1.next # 2</code></pre>

<p>Todos los objetos tienen un método llamado <code class="highlighter-rouge">class</code> que nos devuelve la clase de la cuál fue creada el objeto:</p>

<pre><code class="language-ruby">puts juan.class # Humano
puts "hola".class # String
puts 1.class # Fixnum</code></pre>

<h2 id="encapsulamiento">Encapsulamiento</h2>

<p>Uno de los mayores problemas de la Programación Procedimental (el paradigma previo a OOP) es que no existía una forma de ocultar información y procedimientos del resto de la aplicación. A medida que la aplicación cambiaba, se empezaban a crear dependencias a partes del código que podían ser muy inestables, y que no estaban diseñadas para que el resto de la aplicación las usara directamente. Esas dependencias hacían muy difícil mantener el código, cualquier cambio dispara varios errores en cadena.</p>

<p><strong>La Programación Orientada por Objetos no soluciona el problema automáticamente, pero nos da herramientas para solucionarlo.</strong> Veamos un ejemplo:</p>

<pre><code class="language-ruby">class CustomerStore
  def initialize
    @customers = {} # los clientes se van a almacenar en un hash
    @next_id = 1 # un consecutivo para asignarle a cada cliente
  end

  def all
    ...
  end

  def create(customer)
    ...
  end

  def delete(customer)
    ...
  end

  private
    def next_customer_id
      @next_id += 1
    end
end</code></pre>

<p>La clase <code class="highlighter-rouge">CustomerStore</code> se encarga de almacenar los clientes (customers) y tiene:</p>

<ul>
  <li>Dos atributos privados llamados <code class="highlighter-rouge">customers</code> y <code class="highlighter-rouge">next_id</code>.</li>
  <li>Tres métodos públicos llamados <code class="highlighter-rouge">all</code>, <code class="highlighter-rouge">create</code> y <code class="highlighter-rouge">delete</code>.</li>
  <li>Un método privado llamado <code class="highlighter-rouge">next_customer_id</code>.</li>
</ul>

<p>En este momento la clase está almacenando los clientes en un hash, pero es posible que en un futuro usemos una base de datos como MySQL o PostgreSQL. <strong>Si la aplicación usara directamente al hash para crear y eliminar los clientes, el cambio sería mucho más difícil</strong>. Lo que estamos haciendo es encapsulando la información y permitiendo que los clientes se creen y se eliminen solo a través de los métodos <code class="highlighter-rouge">create</code> y <code class="highlighter-rouge">delete</code>. De esta forma será más fácil cambiar el tipo de almacenamiento en un futuro.</p>

<p><strong>Por defecto, los atributos de un objeto en Ruby son privados</strong>, es decir, solo pueden ser accedidos por métodos de la misma clase. Para darles visibilidad desde otras partes de la aplicación se usa <code class="highlighter-rouge">attr_accessor</code> (lectura y escritura), <code class="highlighter-rouge">attr_reader</code> (lectura), y <code class="highlighter-rouge">attr_writer</code> (escritura).</p>

<p>Los métodos pueden ser <code class="highlighter-rouge">públicos</code>, <code class="highlighter-rouge">privados</code>, o <code class="highlighter-rouge">protegidos</code>, y se definen de la siguiente forma:</p>

<pre><code class="language-ruby">class MyClass
  # acá van los métodos públicos

  protected
    # acá van los métodos protegidos

  private
    # acá van los métodos privados
end</code></pre>

<p>Los métodos <strong>públicos</strong> pueden ser accedidos desde cualquier parte de la aplicación. Los métodos <strong>privados</strong> y <strong>protegidos</strong> pueden ser accedidos desde la misma clase o desde alguna de sus subclases (la diferencia exacta es sutil y no muy relevante para nuestra discusión). Las subclases son el tema de la siguiente sección.</p>

<h2 id="herencia">Herencia</h2>

<p>La herencia es un mecanismo de reutilización de código en la Programación Orientada por Objetos. A través de la herencia, <strong>una clase hereda de otra sus atributos y métodos</strong>. Técnicamente, los atributos no son heredados, se heredan los métodos que permiten leerlos o escribirlos (que se crean usando <code class="highlighter-rouge">attr_accessor</code>, <code class="highlighter-rouge">attr_reader</code>, y <code class="highlighter-rouge">attr_writer</code>).</p>

<p>Supongamos que estamos diseñando un sistema que permite a las empresas llevar un control de sus facturas, ingresos y gastos. Podríamos crear tres clases independientes que representen una factura, un ingreso, y un gasto respectivamente. Pero hay información que se duplicaría en las tres clases: el usuario, la fecha, el concepto, y el valor.</p>

<p>La solución es crear una <strong>clase padre</strong> llamada <code class="highlighter-rouge">Transaction</code> y tres <strong>clases</strong> (subclases) llamadas <code class="highlighter-rouge">Invoice</code>, <code class="highlighter-rouge">Income</code>, y <code class="highlighter-rouge">Expense</code> que heredan de <code class="highlighter-rouge">Transaction</code>. La herencia se define usando la notación <code class="highlighter-rouge">&lt;</code>:</p>

<pre><code class="language-ruby">class Transaction
  attr_accessor :user, :date, :concept, :amount
end

class Invoice &lt; Transaction
  attr_accesor :number
end

class Income &lt; Transaction
end

class Expense &lt; Transaction
end</code></pre>

<p><code class="highlighter-rouge">Transaction</code> define cuatro atributos: <code class="highlighter-rouge">user</code>, <code class="highlighter-rouge">date</code>, <code class="highlighter-rouge">concept</code>, y <code class="highlighter-rouge">amount</code>. <code class="highlighter-rouge">Invoice</code> define un atributo adicional llamado <code class="highlighter-rouge">number</code>.</p>

<p>Los atributos y métodos definidos en la clase padre se acceden de la misma forma en que se acceden los atributos y métodos definidos en la clase que hereda:</p>

<pre><code class="language-ruby">invoice = Invoice.new
invoice.user = "German Escobar" # definido en la clase padre
invoice.amount = 12000 # definido en la clase padre
invoice.number = 1

puts invoice.amount # definido en la clase padre
puts invoice.number</code></pre>

<p>Es posible que una clase sea clase padre y subclase a la vez como se muestra en el siguiente diagrama:</p>

<p><img src="/assets/images/class-diagram.png" alt="Screenshots" class="photo" /></p>

<p><strong>Nota</strong>: En Ruby una subclase solo puede tener una clase padre.</p>

<h3 id="sobrescribiendo-métodos">Sobrescribiendo métodos</h3>

<p>¿Qué pasa si una clase define un método con el mismo nombre (y los mismos argumentos) de un método en la clase padre? A esto se le llama sobrescritura de métodos y es una práctica muy común para cambiar el comportamiento de la clase padre.</p>

<p>Supongamos que estamos implementando una aplicación que calcula el salario de los empleados de una empresa. A todos los empleados se les calcula el salario de la misma forma, exceptuando a los directores, que reciben un bono adicional:</p>

<pre><code class="language-ruby">class Employee
  attr_accessor :name, :salary

  def net_salary
    salary - (salary * 0.12)
  end
end

class Manager &lt; Employee
  attr_accessor :bonus

  def net_salary
    salary - (salary * 0.12) + bonus
  end
end</code></pre>

<p>En este ejemplo <code class="highlighter-rouge">Manager</code> está sobrescribiendo <code class="highlighter-rouge">net_salary</code> para agregar el bono. Sin embargo, estamos duplicando código (el cálculo del salario base). Usaremos las herramientas que nos brinda OOP para mejorarlo:</p>

<pre><code class="language-ruby">class Employee
  attr_accessor :name, :salary

  def net_salary
    base_salary
  end

  protected
    def base_salary
      salary - (salary * 0.12)
    end
end

class Manager &lt; Employee
  attr_accessor :bonus

  def net_salary
    base_salary + bonus
  end
end</code></pre>

<p>¿Puedes encontrar la diferencia con el código anterior? Definimos un método protegido <code class="highlighter-rouge">base_salary</code> (para que solo sea visible en la clase y sus subclases) y lo usamos en las dos clases para solucionar la duplicación de código. Si, son más líneas de código, pero si más adelante cambia la forma en que se calcula el salario base, solo tenemos que hacer el cambio en un único lugar.</p>

<h2 id="polimorfismo">Polimorfismo</h2>

<p>Supongamos que necesitamos escribir una función que dibuje figuras en la pantalla. La función debe recibir una figura y unas coordenadas, y dibujar la figura en esas coordenadas. Una posible solución sería la siguiente:</p>

<pre><code class="language-ruby">def draw_figure(figure, x, y)
  set_coordinates(x, y)
  if figure == "circle"
    # draw a circle
  elsif figure == "triangle"
    # draw a triangle
  elsif figure == "square"
    # draw a square
  end
end</code></pre>

<p>Este código tiene dos problemas. El primero es que no está teniendo en cuenta el tamaño de la figura. El segundo, más grave, es que para dibujar una figura diferente tenemos que modificar la función. Usemos OOP para solucionar esos problemas:</p>

<pre><code class="language-ruby">def draw_figure(figure, x, y)
  set_coordinates(x, y)
  figure.draw
end

class Circle
  attr_accessor :radius

  def draw
    ...
  end
end

class Triangle
  attr_accessor :base, :height

  def draw
    ...
  end
end</code></pre>

<p><code class="highlighter-rouge">draw_figure</code> ahora acepta cualquier objeto que responda al método <code class="highlighter-rouge">draw</code> (a esto se le llama <strong>el contrato</strong>). <code class="highlighter-rouge">Circle</code> y <code class="highlighter-rouge">Triangle</code> cumplen el contrato y por lo tanto podemos usarlos en <code class="highlighter-rouge">draw_figure</code>.</p>

<p>A eso se le llama polimorfismo. Formalmente se define como la capacidad de un objeto de tomar otra(s) forma(s). En nuestro caso, cualquier clase que defina un método <code class="highlighter-rouge">draw</code> se puede usar como argumento de <code class="highlighter-rouge">draw_figure</code>. En Ruby, a esto se le llama <a href="http://en.wikipedia.org/wiki/Duck_typing" target="_blank">duck typing</a>. Desde que se cumpla con el contrato, no importa qué clase sea o qué otros atributos/métodos defina.</p>

<p><strong>Nota</strong>: Otros lenguajes de programación como Java y C++ utilizan un concepto llamado interfaces para definir el contrato (o los métodos que debe implementar una clase para cumplir el contrato), pero la idea es la misma.</p>

<h2 id="módulos-mixins">Módulos (Mixins)</h2>

<p>En Ruby, los módulos cumplen una doble función. Se usan para evitar colisiones en los nombres de las clases (namespaces) y como un mecanismo de reutilización de código (mixins). En esta sección nos vamos a concentrar en esto último, la reutilización de código.</p>

<p>Los mixins son ideales para aquellas situaciones en que es necesario incluir (o mezclar) métodos en diferentes clases que no comparten nada en común. Por ejemplo, imagina que quisieramos almacenar los atributos de diferentes objetos en archivos (en algún formato como JSON o XML). Podemos crear un módulo (llamémoslo <code class="highlighter-rouge">Persistable</code>) que podemos mezclar en cualquier clase:</p>

<pre><code class="language-ruby">module Persistable
  def store(path)
    ...
  end

  def load(path)
    ...
  end
end</code></pre>

<p>Para mezclar el módulo dentro de una clase usamos la palabra clave <code class="highlighter-rouge">include</code>:</p>

<pre><code class="language-ruby">class User
  include Persistable
  attr_accessor :id, :name, :email
  ...
end

class Post
  include Persistable
  attr_accessor :id, :date, :content
  ...
end</code></pre>

<p>Ahora <code class="highlighter-rouge">User</code> y <code class="highlighter-rouge">Post</code> incluyen dos métodos adicionales <code class="highlighter-rouge">store</code> y <code class="highlighter-rouge">load</code> que los podemos usar de la siguiente forma:</p>

<pre><code class="language-ruby">user = User.new
user.load('/users/user-1.xml')

user.name = "Juan Perez"
user.email = "change@gmail.com"

user.save('/users/user-1.xml')</code></pre>

<p>Si necesitamos cambiar la forma en que los objetos son almacenados, el único lugar que necesitamos modificar es el módulo <code class="highlighter-rouge">Persistable</code>.</p>
</div>

                <div class="share-post">
                  <span class="text">Compartir en:</span>
                  <div class="social-networks">
                    <a class="btn-share btn-share-twitter" target="_blank" href="http://twitter.com/share?text=Programación Orientada por Objetos en Ruby&url=http://blog.makeitreal.camp/programacion-orientada-por-objetos-ruby/&via=makeitrealcamp" rel="nofollow" title="Compartir en Twitter">Twitter</a>
                    <a class="btn-share btn-share-fb" target="_blank" href="http://www.facebook.com/sharer.php?u=http://blog.makeitreal.camp/programacion-orientada-por-objetos-ruby/&p[title]=Programación Orientada por Objetos en Ruby" rel="nofollow" title="Compartir en Facebook">Facebook</a>
                    <a class="btn-share btn-share-linkedin" target="_blank" href="http://www.linkedin.com/shareArticle?mini=true&url=http://blog.makeitreal.camp/programacion-orientada-por-objetos-ruby/&title=Programación Orientada por Objetos en Ruby&summary=&source=http://blog.makeitreal.camp/programacion-orientada-por-objetos-ruby/" rel="nofollow" title="Compartir en LinkedIn">LinkedIn</a>
                  </div>
                </div>

                <div class="post-magnet">
  <div class="row">
    <div class="col-md-6 text-center">
      <div class="img-wrapper">
        <h3>Descarga gratis la guía para convertirte en Desarrollador Web</h3>
        <img src="https://makeitreal.s3.amazonaws.com/images/books/web-developer-guide-book.png" alt="¿Cómo convertirte en Desarrollador Web?">
      </div>
    </div>
    <div class="col-md-6">
      <form action="https://makeitreal.camp/como-convertirte-en-web-developer" class="content-wrapper" method="post">
        <div class="form-group">
          <div class="row">
            <div class="col-6"><input type="text" id="first_name" name="first_name" class="form-control" placeholder="Nombre" required></div>
            <div class="col-6"><input type="text" id="last_name" name="last_name" class="form-control" placeholder="Apellido" required></div>
          </div>
        </div>
        <div class="form-group">
          <div class="form-group">
            <input type="email" id="email" name="email" class="form-control" placeholder="Ingresa tu email" required>
          </div>
        </div>
        <div class="form-group">
          <select name="goal" id="goal" class="form-control" required>
            <option value=""><< Selecciona >></option>
            <option value="change-career">Quiero cambiar de carrera</option>
            <option value="complement-career">Estudio Sistemas (o algo relacionado) y quiero complementar</option>
            <option value="improve-skills">Quiero actualizar/mejorar mis conocimientos en programación</option>
            <option value="create-products">Soy emprendedor</option>
          </select>
        </div>
        <div>
          <button type="submit" class="btn btn-primary" style="margin-top: 20px;">Descargar guía</button>
        </div>
      </form>
    </div>
  </div>
</div>

              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="row justify-content-md-center">
      <div class="col-sm-8">
        <div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'makeitreal'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

      </div>
    </div>
  </div>
</div>
</div>
    <footer class="main">

    </footer>
  </body>
</html>
